'''
* Return-to-Win
* Return-to-System
Return-to-Execve
* Return-to-Syscall
Return-to-Libc (OneGadget)
ROP Write Primitive
* Format Strings Stack Leak
Format Strings Libc Leak
Format Strings Write Primitive
Format Strings GOT Overwrite
'''

import re
import json
import r2pipe
from pwn import *

# make pwntools shut up
context.log_level = 'warning'


# Identify solution set from binary.
# i.e. write a tool that's sole purpose is identifying which techniques we need to use.

class analyze:
    def __init__(self, binary):
        self.binary = binary
        self.r2 = r2pipe.open(binary) # open binary
        self.r2.cmd('aaa') # anilize binary
        self.izz = json.loads(self.r2.cmd('izzj')) # returns json relating to strings
        self.afl = json.loads(self.r2.cmd('aflj')) # returns json relating to functions
        self.strings = [i['name'] for i in self.izz if 'name' in i] # returns list of strings
        self.functions = [i['name'] for i in self.afl if 'name' in i] # returns list of functions
        
    def test(self):
        print(self.functions)
        print(self.strings)

    def has_binsh(self):
        return '/bin/sh' in self.strings

    def has_flagtxt(self):
        return 'flag.txt' in self.strings

    def has_gets(self):
        return 'sym.imp.gets' in self.functions

    def has_win(self):
        return 'sym.win' in self.functions

    def has_system(self):
        return 'sym.imp.system' in self.functions

    def has_printf(self):
        return 'sym.imp.printf' in self.functions

    def has_syscall(self):
        return 'sym.imp.syscall' in self.functions

    def has_format(self):
        return not self.has_win() and not self.has_rop()

    def has_rop(self):
        return any((match := re.compile(r'gadget*').match(i)) for i in self.functions)

    def has_buffoverflow(self):
        io = process(self.binary)
        io.sendline(b'A'*2048)
        try:
            io.recvline()
        except:
            return True
        return False

    def has_leak(self):
        io = process(self.binary)
        io.sendline(b'%1p')
        try:
            return '0x' in io.recvline().encode('utf-8')
        except:
            return True




#strings = r2.cmd('izzj | jq -r \'.[].string\'').split('\n')
#functions = r2.cmd('aflj | jq -r \'.[].name\'').split('\n')
#strings = [i['string'] for i in json.loads(r2.cmd('izzj')) if 'string' in i]
#functions = [i['name'] for i in json.loads(r2.cmd('aflj')) if 'name' in i]
#functions = elf(binary).symbols
