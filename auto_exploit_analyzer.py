'''
* Return-to-Win
* Return-to-System
Return-to-Execve
* Return-to-Syscall
Return-to-Libc (OneGadget)
ROP Write Primitive
* Format Strings Stack Leak
Format Strings Libc Leak
Format Strings Write Primitive
Format Strings GOT Overwrite
'''

import re
import json
import r2pipe
from pwn import *
# Identify solution set from binary. i.e. write a tool that's sole purpose is identifying which techniques we need to use.

def analyze(file):
    context.log_level = 'warning'

    global ae_binary
    global ae_strings
    global ae_functions

    # define binary
    ae_binary = file
    
    # define strings & functions
    r2 = r2pipe.open(ae_binary)
    r2.cmd('aaa') # anilize binary
    ae_strings = r2.cmd('izzj | jq -r \'.[].string\'').split('\n')
    ae_functions = r2.cmd('aflj | jq -r \'.[].name\'').split('\n')
    #ae_strings = [i['string'] for i in json.loads(r2.cmd('izzj')) if 'string' in i]
    #ae_functions = [i['name'] for i in json.loads(r2.cmd('aflj')) if 'name' in i]
    #ae_functions = ELF(ae_binary).symbols

def test():
    return ae_functions
def has_binsh():
    return '/bin/sh' in ae_strings

def has_flagtxt():
    return 'flag.txt' in ae_strings

def has_gets():
    return 'sym.imp.gets' in ae_functions

def has_win():
    return 'sym.win' in ae_functions

def has_system():
    return 'sym.imp.system' in ae_functions

def has_printf():
    return 'sym.imp.printf' in ae_functions

def has_syscall():
    return 'sym.imp.syscall' in ae_functions


def has_buffoverflow():
    io = process(ae_binary)
    io.sendline(b'A'*2048)
    try:
        io.recvline()
    except:
        return True
    return False

def has_rop():
    return any((match := re.compile(r'gadget*').match(i)) for i in ae_functions)

def has_leak():
    io = process(ae_binary)
    io.sendline(b'%1p')
    try:
        return '0x' in io.recvline().encode('utf-8')
    except:
        return True

def has_format():
    return not has_win() and not has_rop()


